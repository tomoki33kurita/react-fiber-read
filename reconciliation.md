# Reconciliation

元記事:https://legacy.reactjs.org/docs/reconciliation.html

React は宣言的な API を提供しているので、更新のたびに何が変わるかを厳密に気にする必要はない。これによってアプリケーションを書くのがとても楽になるのだが、React の中でこれがどのように実装されているかは、あまり知られていないかもしれない。

本記事では、React の「差分」アルゴリズムにおいて、コンポーネントの更新が予測可能でありながら、高性能なアプリに十分な速度が出るようにした選択について説明する。

## **Motivation**

React を使用する場合、ある時点で render()関数は React 要素のツリーを作成すると考えることができる。次のステートまたはプロップの更新時に、その render()関数は React 要素の異なるツリーを返します。そして React は、最新のツリーに合わせて UI を効率的に更新する方法を見つけ出す必要がある。

ある木を別の木に変換するための最小数の操作を生成するというこのアルゴリズム問題には、いくつかの一般的な解決策がある。しかし、最新のアルゴリズムでは、O(n3)（n はツリーの要素数）のオーダーの複雑さがある。

React でこれを使うと、1000 個の要素を表示するのに 10 億回の比較が必要になる。これはあまりにも高価だ。代わりに React は、2 つの仮定に基づく発見的な O(n)アルゴリズムを実装している：

1. 異なるタイプの 2 つの要素は、異なる樹木を生み出す。
2. 開発者は、どの子要素が異なるレンダリングにまたがって安定しているかを、key prop で示唆することができます。

実際には、これらの仮定はほとんどすべての実用的なユースケースで有効である。

## The Diffing Algorithm

2 つのツリーを差分するとき、React はまず 2 つのルート要素を比較する。この動作は、ルート要素の型によって異なります。

### Elements Of Different Types

ルート要素の型が異なる場合、React は古いツリーを破棄し、新しいツリーを最初から構築します。`<a>` から `<img>`、`<Article>` から `<Comment>`、`<Button>` から `<div>` など、いずれの場合も完全な再構築が行われます。

ツリーを破棄すると、古い DOM ノードは破棄されます。コンポーネントインスタンスは、`componentWillUnmount()` を受け取ります。新しいツリーを構築すると、新しい DOM ノードが DOM に挿入されます。コンポーネントインスタンスは、`UNSAFE_componentWillMount()` を受け取り、次に`componentDidMount()` を受け取ります。古いツリーに関連付けられていた状態はすべて失われます。

ルート以下のコンポーネントもアンマウントされ、状態は破棄されます。例えば、diff を実行すると次のようになります。

```tsx
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```

これにより、古いカウンターが破棄され、新しいカウンターが再マウントされます。

```tsx
注:

このメソッドはレガシーメソッドとみなされるため、新しいコードでは使用しないでください。

UNSAFE_componentWillMount()
```

### DOM Elements Of The Same Type

同じ型の 2 つの React DOM 要素を比較する場合、React は両方の属性を参照し、基盤となる DOM ノードはそのままにして、変更された属性のみを更新します。例えば：

```tsx
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

これら 2 つの要素を比較することで、React は基になる DOM ノードの className のみを変更すればよいことを認識します。

スタイルを更新する場合も、React は変更されたプロパティのみを更新すればよいことを認識します。例えば、次のようになります。

```tsx
<div style={{color: 'red', fontWeight: 'bold'}} />

<div style={{color: 'green', fontWeight: 'bold'}} />
```

これら 2 つの要素を変換する際、React は fontWeight ではなく、カラースタイルのみを変更することを認識しています。

DOM ノードを処理した後、React は子要素を再帰的に処理します。

### Component Elements Of The Same Type

コンポーネントが更新されてもインスタンスはそのまま維持されるため、レンダリングをまたいで状態が維持されます。React は、新しい要素に合わせて基になるコンポーネントインスタンスのプロパティを更新し、基になるインスタンスに対して `UNSAFE_componentWillReceiveProps()`、`UNSAFE_componentWillUpdate()`、および`componentDidUpdate()` を呼び出します。

次に、`render()` メソッドが呼び出され、diff アルゴリズムが前の結果と新しい結果を再帰的に処理します。

```tsx
注:

以下のメソッドはレガシーメソッドとみなされるため、新しいコードでは使用しないでください。

UNSAFE_componentWillUpdate()
UNSAFE_componentWillReceiveProps()
```

### Recursing On Children

デフォルトでは、DOM ノードの子要素を再帰的に処理する場合、React は両方の子要素のリストを同時に反復処理し、差異がある場合はミューテーションを生成します。

例えば、子要素の末尾に要素を追加する場合、以下の 2 つのツリー間の変換は正常に機能します。

```tsx
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

React は 2 つの`<li>first</li>`ツリーをマッチさせ、2 つの`<li>second</li>`ツリーをマッチさせ、最後に`<li>third</li>`ツリーを挿入します。

単純に実装すると、先頭に要素を挿入するとパフォーマンスが低下します。例えば、以下の 2 つのツリー間の変換はうまく動作しません。

```tsx
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

React は、`<li>Duke</li>`と`<li>Villanova</li>`のサブツリーをそのまま維持できることに気づかず、すべての子ツリーを変更してしまいます。この非効率性が問題となる可能性があります。

### Keys

この問題を解決するために、React は`key`属性をサポートしています。子要素に key がある場合、React はその key を使用して、元のツリーの子要素と後続のツリーの子要素をマッチングします。例えば、上記の非効率的な例に key を追加すると、ツリーの変換が効率的になります。

```tsx
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

これで、React はキー '2014' を持つ要素が新しいものであり、キー '2015' と '2016' を持つ要素が移動したことを認識します。

実際には、キーを見つけるのは通常それほど難しくありません。表示しようとしている要素に既に一意の ID がある場合、キーはデータから取得できます。

```tsx
<li key={item.id}>{item.name}</li>
```

そうでない場合は、モデルに新しい ID プロパティを追加するか、コンテンツの一部をハッシュ化してキーを生成できます。キーは、グローバルに一意である必要はなく、兄弟要素間で一意である必要があります。

最後の手段として、配列内のアイテムのインデックスをキーとして渡すこともできます。アイテムが並べ替えられない場合はうまく機能しますが、並べ替えは遅くなります。

インデックスをキーとして使用した場合、並べ替えによってコンポーネントの状態に問題が発生することもあります。コンポーネントインスタンスは、キーに基づいて更新および再利用されます。キーがインデックスの場合、アイテムを移動するとキーも変更されます。その結果、制御されていない入力などのコンポーネントの状態が混乱し、予期しない方法で更新される可能性があります。

こちらは、CodePen でインデックスをキーとして使用することで発生する可能性のある問題の例です。こちらは、同じ例の更新版で、インデックスをキーとして使用しないことで、並べ替え、ソート、および先頭への追加に関するこれらの問題がどのように修正されるかを示しています。

## Tradeoffs

調整アルゴリズムは実装の詳細であることを覚えておくことが重要です。React はアクションごとにアプリ全体を再レンダリングできますが、最終結果は同じです。念のため補足すると、ここでの rerender とは、すべてのコンポーネントに対して render を呼び出すことを意味し、React がコンポーネントをアンマウントして再マウントすることを意味するものではありません。React は、前のセクションで説明したルールに従って差異を適用するだけです。

一般的なユースケースを高速化するため、ヒューリスティックを定期的に改良しています。現在の実装では、サブツリーが兄弟間で移動されたという事実は表現できますが、別の場所に移動されたことは表現できません。アルゴリズムは、そのサブツリー全体を再レンダリングします。

React はヒューリスティックに依存しているため、その背後にある仮定が満たされないと、パフォーマンスが低下します。

1. このアルゴリズムは、異なるコンポーネントタイプのサブツリーをマッチングさせようとはしません。非常に似た出力を持つ 2 つのコンポーネントタイプを交互に使用することが予想される場合は、同じタイプにすることをお勧めします。実際には、これが問題になることは確認されていません。
2. キーは安定的で、予測可能かつ一意である必要があります。不安定なキー（Math.random() によって生成されるキーなど）は、多くのコンポーネントインスタンスと DOM ノードを不必要に再作成する原因となり、パフォーマンスの低下や子コンポーネントの状態の消失を引き起こす可能性があります。
