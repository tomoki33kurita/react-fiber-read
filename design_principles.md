# Design Principles

デザイン原則

元記事：https://legacy.reactjs.org/docs/design-principles.html

このドキュメントは、React が何をするか、何をしないかをどのように決定するか、そして私たちの開発哲学がどのようなものかを、より深く理解していただくために作成しました。コミュニティからの貢献は大変喜ばしいことですが、これらの原則のいずれか、あるいは複数に違反するような道を選ぶことはまずありません。

```tsx
注:

このドキュメントは、React に関する深い知識を前提としています。React 自体の設計原則について説明しており、React コンポーネントやアプリケーションについては説明していません。
React の入門書として、Thinking in React をご覧ください。
```

https://react.dev/learn/thinking-in-react

### Composition

React の重要な特徴は、コンポーネントのコンポジションです。異なる人が作成したコンポーネントは、互いにうまく連携して動作するはずです。コードベース全体に波及効果を与えることなく、コンポーネントに機能を追加できることが、私たちにとって重要です。

例えば、コンポーネントにローカル状態を導入する際に、それを使用しているコンポーネントを変更する必要がないようにする必要があります。同様に、必要に応じて、任意のコンポーネントに初期化およびティアダウンのコードを追加できる必要があります。

コンポーネントで状態メソッドやライフサイクルメソッドを使用することは、「悪いこと」ではありません。他の強力な機能と同様に、これらは適度に使用する必要がありますが、削除するつもりはありません。むしろ、これらは React を有用なものにする上で不可欠な要素だと考えています。将来的にはさらに多くの関数型パターンを有効にする可能性がありますが、ローカル状態メソッドとライフサイクルメソッドはどちらもそのモデルの一部となります。

コンポーネントはしばしば「単なる関数」と表現されますが、私たちは、有用であるためにはそれ以上のものである必要があると考えています。React では、コンポーネントはレンダリング、ライフサイクル、状態など、構成可能なあらゆる動作を記述します。 Relay のような外部ライブラリの中には、データ依存関係の記述といったコンポーネントの役割を拡張するものがあります。こうしたアイデアが何らかの形で React にも取り入れられる可能性はあります。

### Common Abstraction

一般的に、ユーザーランドで実装できる機能の追加には抵抗があります。無駄なライブラリコードでアプリを肥大化させたくないからです。しかし、これには例外もあります。

例えば、React がローカルステートやライフサイクルメソッドをサポートしていない場合、ユーザーはそれらのためのカスタム抽象化を作成するでしょう。複数の抽象化が競合している場合、React はどちらかの特性を強制したり、活用したりすることができません。React は、最も低い公約数で動作する必要があります。

だからこそ、React 自体に機能を追加することがあります。多くのコンポーネントが特定の機能を互換性のない、あるいは非効率的な方法で実装していることに気付いた場合、その機能を React に組み込むことを検討することがあります。私たちは軽々しくそうすることはありません。そうするのは、抽象化レベルを上げることがエコシステム全体に利益をもたらすと確信しているからです。ステート、ライフサイクルメソッド、クロスブラウザイベントの正規化などは、その良い例です。

私たちは、このような改善提案については常にコミュニティと議論しています。これらの議論の一部は、React 問題追跡ツールの「全体像」ラベルで見つけることができます。

### Escape Hatches

React は実用的です。Facebook で開発された製品のニーズによって推進されています。関数型プログラミングなど、まだ完全には主流ではないパラダイムの影響を受けていますが、スキルや経験レベルが異なる幅広い開発者が利用できるようにすることが、このプロジェクトの明確な目標です。

気に入らないパターンを非推奨にする場合は、そのパターンの既存のユースケースをすべて検討し、非推奨にする前にコミュニティに代替案を周知させる責任があります。アプリ構築に役立つパターンであっても、宣言的な方法で表現するのが難しい場合は、命令型の API を提供します。多くのアプリで必要だとわかったものに対して完璧な API が見つからない場合は、後で削除でき、将来の改善の余地が残されている限り、一時的に機能する API を提供します。

### Stability

私たちは API の安定性を重視しています。Facebook では、React を使用したコンポーネントが 5 万以上あります。Twitter や Airbnb など、他の多くの企業も React をヘビーユーザーです。そのため、私たちは通常、公開 API やその動作を変更することには消極的です。

しかし、「何も変わらない」という意味での安定性は過大評価されていると考えています。それはすぐに停滞につながります。私たちはむしろ、「本番環境で頻繁に使用されており、何かが変更された場合でも、明確な（できれば自動化された）移行パスがある」という意味での安定性を重視しています。

パターンを非推奨にする場合は、Facebook 社内での使用状況を調査し、非推奨の警告を追加します。これにより、変更の影響を評価できます。変更が時期尚早であると判断し、コードベースをこの変更に対応できる状態にするために、より戦略的に検討する必要があると判断した場合は、変更を取りやめることもあります。

変更が大きな混乱を招かず、移行戦略があらゆるユースケースで実行可能であると確信できる場合、オープンソースコミュニティに非推奨の警告を公開します。Facebook 社以外でも多くの React ユーザーと緊密に連携し、人気のオープンソースプロジェクトを監視し、非推奨の修正を支援しています。

Facebook React のコードベースの規模の大きさを考えると、社内移行が成功すれば、他の企業でも問題が発生しないという良い指標となることがよくあります。しかしながら、私たちが想定していなかった新たなユースケースを指摘されることもあり、その場合は対応策を追加したり、アプローチを再考したりします。

正当な理由なく非推奨にすることはありません。非推奨の警告がフラストレーションの原因となる場合もあることは承知していますが、非推奨にすることで、私たちやコミュニティの多くのメンバーが価値あると考える改善や新機能への道が開かれるため、非推奨化を推奨しています。

例えば、React 15.2.0 では未知の DOM プロパティに関する警告を追加しました。多くのプロジェクトがこの影響を受けました。しかし、この警告を修正することは、React にカスタム属性のサポートを導入するために重要です。私たちが追加するすべての非推奨化には、このような理由があります。

非推奨化の警告を追加した場合、その警告は現在のメジャーバージョンの残りの期間はそのまま保持され、次のメジャーバージョンで動作が変更されます。手作業による反復作業が多い場合は、変更の大部分を自動化する codemod スクリプトをリリースします。codemod は、大規模なコードベースを停滞させることなく前進することを可能にし、皆さんにもぜひ活用していただきたいと考えています。

リリースした codemod は react-codemod リポジトリでご覧いただけます。

### Interoperability

私たちは、既存システムとの相互運用性と段階的な導入を非常に重視しています。Facebook は React 以外の大規模なコードベースを保有しています。同社のウェブサイトでは、XHP と呼ばれるサーバーサイドコンポーネントシステム、React 以前に登場した内部 UI ライブラリ、そして React 自体が混在しています。私たちにとって重要なのは、どのプロダクトチームも、コードを書き直して React に頼るのではなく、小さな機能から React を使い始められることです。

だからこそ、React は可変モデルを扱うためのエスケープハッチを提供し、他の UI ライブラリとの連携をスムーズに行えるようにしています。既存の命令型 UI を宣言型コンポーネントでラップすることも、その逆も可能です。これは段階的な導入において非常に重要です。

### Scheduling

コンポーネントが関数として記述されている場合でも、React を使用する際にはそれらを直接呼び出すことはありません。すべてのコンポーネントは、レンダリングが必要な内容の記述を返します。この記述には、<LikeButton> のようなユーザーが作成したコンポーネントと、<div> のようなプラットフォーム固有のコンポーネントの両方が含まれる場合があります。<LikeButton> を将来のある時点で「展開」し、コンポーネントのレンダリング結果に基づいて UI ツリーに実際に変更を適用するのは、React の役割です。

これは微妙な違いですが、非常に重要な違いです。コンポーネント関数を呼び出すのではなく、React に呼び出しさせるため、React は必要に応じて呼び出しを遅らせることができます。現在の実装では、React はツリーを再帰的に走査し、更新されたツリー全体のレンダリング関数を 1 回のティックで呼び出します。しかし、将来的にはフレーム落ちを避けるために、一部の更新を遅らせるようになるかもしれません。

これは React の設計における一般的なテーマです。いくつかの人気ライブラリは、新しいデータが利用可能になったときに計算を実行する「プッシュ」アプローチを実装しています。しかし、React は、計算を必要になるまで遅らせることができる「プル」アプローチに固執しています。

React は汎用的なデータ処理ライブラリではありません。ユーザーインターフェースを構築するためのライブラリです。React は、アプリにおいて、どの計算が現在重要で、どの計算がそうでないかを判断する上で、独自の位置付けにあると考えています。

画面外にあるものがあれば、それに関連するロジックを遅延させることができます。フレームレートよりも速くデータが到着している場合は、更新を統合してバッチ処理することができます。フレーム落ちを回避するために、ユーザーインタラクションによる処理（ボタンクリックによるアニメーションなど）を、それほど重要でないバックグラウンド処理（ネットワークから読み込まれたばかりの新しいコンテンツのレンダリングなど）よりも優先させることができます。

念のため言っておきますが、現時点ではこの機能を活用していません。しかし、このような処理を自由に行えるため、スケジューリングを制御でき、setState()が非同期である理由もそこにあります。概念的には、「更新のスケジュール設定」だと考えています。

関数型リアクティブプログラミングのいくつかのバリエーションで一般的な「プッシュ」ベースのパラダイムを用いて、ユーザーが直接ビューを構成できるようにした場合、スケジューリングの制御は難しくなります。私たちは「グルー」コードを所有したいのです。

React にとって重要な目標は、React に制御を戻す前に実行されるユーザーコードの量を最小限にすることです。これにより、React は UI に関する知識に基づいてスケジューリングを行い、作業をチャンクに分割する機能を維持できます。

チーム内では、React は完全に「リアクティブ」になりたくないので、「スケジュール」と呼ぶべきだったというジョークがあります。

### Developer Experience

優れた開発者エクスペリエンスを提供することは、私たちにとって重要です。

例えば、Chrome と Firefox で React のコンポーネントツリーを検査できる React DevTools を提供しています。Facebook のエンジニアとコミュニティの両方にとって、このツールが生産性を大幅に向上させていると聞いています。

また、開発者向けの役立つ警告の提供にも力を入れています。例えば、React は開発中にブラウザが理解できない方法でタグをネストしたり、API でよくあるタイプミスをしたりすると警告を表示します。React の開発版が本番版よりも遅くなる主な理由は、開発者向けの警告と関連するチェック機能です。

Facebook 社内で見られる使用パターンは、よくある間違いを理解し、早期に防ぐ方法を見つけるのに役立ちます。新機能を追加する際には、よくある間違いを予測し、警告を表示するように努めています。

私たちは常に開発者エクスペリエンスを向上させる方法を模索しています。皆様からのご提案をお待ちしております。そして、より良いものにするために、皆様の貢献を歓迎いたします。

### Debugging

何か問題が発生した場合は、コードベース内の原因までたどり着くためのパンくずリストを用意しておくことが重要です。React では、props と state がまさにそのパンくずリストです。

画面に何か問題が見つかった場合は、React DevTools を開き、レンダリングを担当するコンポーネントを見つけて、props と state が正しいかどうかを確認できます。正しい場合は、問題はコンポーネントの render()関数、または render()によって呼び出される関数にあることがわかります。つまり、問題は切り分けられます。

state が間違っている場合は、このファイル内の setState()呼び出しの 1 つが原因であるとわかります。通常、1 つのファイルには setState()呼び出しが数個しかないため、これも比較的簡単に特定して修正できます。

props が間違っている場合は、インスペクタでツリーを上方向にたどり、最初に不正な props を渡して「井戸に毒を注入した」コンポーネントを探すことができます。

あらゆる UI を、現在の props と state という形で生成元データまで追跡できる機能は、React にとって非常に重要です。state がクロージャやコンビネータに「閉じ込められる」ことなく、React から直接利用できるようにすることが、明確な設計目標です。

UI は動的ですが、props と state の同期 render()関数によって、デバッグ作業は推測作業から退屈ながらも有限な手順へと変わると考えています。複雑なアニメーションなど、一部のユースケースでは実装が難しくなるとはいえ、React でもこの制約を維持したいと考えています。

### Configuration

グローバルランタイム設定オプションには問題があると考えています。

例えば、React.configure(options) や React.register(component) のような関数の実装を求められることが時々あります。しかし、これは複数の問題を引き起こし、適切な解決策をまだ見出せていません。

サードパーティのコンポーネントライブラリからそのような関数を呼び出した場合はどうなるでしょうか？ある React アプリが別の React アプリを埋め込み、それらの設定に互換性がない場合はどうなるでしょうか？サードパーティのコンポーネントは、特定の設定が必要であることをどのように指定できるでしょうか？グローバル設定はコンポジションと相性が悪いと考えています。コンポジションは React の中核を成すため、コード内ではグローバル設定を提供していません。

ただし、ビルドレベルではいくつかのグローバル設定を提供しています。例えば、開発ビルドと本番ビルドを別々に提供しています。将来的にはプロファイリングビルドを追加する可能性があり、その他のビルドフラグについても検討中です。

### Beyond the DOM

React の価値は、バグが少なく、互いにうまく連携するコンポーネントを記述できる点にあります。DOM は React の本来のレンダリングターゲットですが、React Native も Facebook とコミュニティの両方にとって同様に重要です。

レンダラーに依存しないことは、React の重要な設計上の制約です。内部表現に若干のオーバーヘッドが発生しますが、一方で、コア部分の改善はプラットフォーム間でも反映されます。

単一のプログラミングモデルを採用することで、プラットフォームではなく製品を中心にエンジニアリングチームを編成できます。これまでのところ、このトレードオフは私たちにとって価値あるものとなっています。

### Implementation

私たちは可能な限りエレガントな API を提供するよう努めています。実装のエレガントさについては、それほど重視していません。現実世界は完璧には程遠く、ユーザーが書く必要がないのであれば、ある程度は醜いコードでもライブラリに組み込むことを好みます。新しいコードを評価する際には、正確でパフォーマンスが高く、優れた開発者エクスペリエンスを提供する実装を求めています。エレガントさは二の次です。

私たちは、巧妙なコードよりも退屈なコードを好みます。コードは使い捨てであり、頻繁に変更されます。そのため、絶対に必要な場合を除き、新しい内部抽象化を導入しないことが重要です。移動、変更、削除が容易な冗長なコードは、時期尚早に抽象化され変更が困難なエレガントなコードよりも優先されます。

### Optimized Tooling

よく使われる API の中には、冗長な名前を持つものがあります。例えば、didMount() や onMount() ではなく、componentDidMount() を使用しています。これは意図的なものです。ライブラリとのやり取りのポイントを明確にするためです。

Facebook のような大規模なコードベースでは、特定の API の使用箇所を検索できることが非常に重要です。特に、使用頻度を低く抑えるべき機能については、冗長な名前が重要になります。例えば、dangerouslySetInnerHTML はコードレビューで見落とすことがありません。

互換性のない変更を行うために codemods に依存しているため、検索の最適化も重要です。コードベース全体に大規模な自動変更を簡単かつ安全に適用できるようにしたいと考えており、冗長な名前はこれを実現するのに役立ちます。同様に、特徴的な名前は、誤検知の可能性を心配することなく、React の使用に関するカスタム lint ルールを簡単に記述できるようにします。

JSX も同様の役割を果たします。React では必須ではありませんが、Facebook では見た目と実用性の両方の理由から、JSX を広く使用しています。

私たちのコードベースでは、JSX はツールに対して、React 要素ツリーを扱っていることを明確に示します。これにより、定数要素のホイスト、安全な lint と codemod による内部コンポーネントの使用、JSX ソースの場所を警告に含めるといったビルド時の最適化が可能になります。

### Dogfooding

コミュニティから提起された問題への対応には、全力を尽くしています。しかし、Facebook 社内でも発生している問題を優先的に扱う傾向があります。直感に反するかもしれませんが、これがコミュニティが React に信頼を寄せる主な理由だと考えています。

社内で React が広く利用されていることから、React が明日消えることはないという確信を得ています。React は Facebook の課題を解決するために開発されました。React は会社に具体的なビジネス価値をもたらし、多くの製品で使用されています。ドッグフーディングを行うことで、私たちのビジョンは明確になり、将来に向けて明確な方向性を持つことができます。

これは、コミュニティから提起された問題を無視するという意味ではありません。例えば、社内では Web コンポーネントと SVG に依存していないにもかかわらず、React にこれらのサポートを追加しました。私たちは皆様のご意見に積極的に耳を傾け、できる限りの対応をしています。コミュニティこそが私たちにとって React を特別なものにしており、私たちはコミュニティに貢献できることを光栄に思います。

Facebook では数多くのオープンソースプロジェクトをリリースする中で、全員を同時に満足させようとすると、焦点が定まらず、成長も鈍化するプロジェクトが生まれてしまうことを学びました。しかし、少数のユーザー層を絞り込み、彼らを満足させることに注力することで、最終的にプラスの効果が得られることを発見しました。まさに React で実践したことであり、Facebook のプロダクトチームが直面していた問題の解決は、オープンソースコミュニティにも大きな影響を与えています。

このアプローチの欠点は、Facebook チームが対応する必要のない「使い始め」体験など、十分な焦点を当てられない場合があることです。私たちはこの点を痛感しており、以前のオープンソースプロジェクトで犯したような過ちを犯すことなく、コミュニティの全員にとって有益な方法で改善する方法を模索しています。
